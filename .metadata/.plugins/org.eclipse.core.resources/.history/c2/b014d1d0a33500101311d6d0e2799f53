/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2022 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "stm32f303xe.h"
#include <stdio.h>
#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

void configUart1(void)
{
	//disable uart 1
    USART1->CR1 &= ~(USART_CR1_UE);

    //clear bits to set
	USART1->CR1 &= ~(USART_CR1_M1      	//word length
					|(0x03 << 26)       // INHIBIT INTERRUPTS AT BITS 26 AND 27     (27/26)
					|USART_CR1_OVER8    // OVERSAMPLING BY 16                       (15)
					|USART_CR1_CMIE     // INHIBIT CHARACTER MATCH INTERRUPT        (14)
					|USART_CR1_MME      // DON'T ENABLE MUTE MODE                   (13)
					|USART_CR1_M0       // CLEAR M0 FOR 1 START BIT AND 8 DATA BITS (12)
					|USART_CR1_PCE      // NOT IMPLEMENTING PARITY CONTROL          (10)
					|(0x1FF));

	//set bits (OVER8 ??? TE weirdness in note???)
    //USART1->CR1 |= 0b1100;


	// CLEAR BITS
    USART1->CR2 &= ~(USART_CR2_RTOEN    // DISABLE RECEIVER TIMEOUT             (23)
                    |USART_CR2_ABREN    // NO AUTOMATIC BAUD RATE DETECTION     (20)
                    |USART_CR2_MSBFIRST // TRANSMIT/RECEIVE LSB FIRST           (19)
                    |(0x03 << 16)       // IDLE STATE HIGH FOR RX/TX PINS       (17/16)
                    |USART_CR2_SWAP     // DON'T SWAP FUNCTION OF RX/TX PINS    (15)
                    |USART_CR2_LINEN    // NO LIN MODE                          (14)
                    |(0x03 << 12)       // 1 STOP BIT                           (13/12)
                    |USART_CR2_CLKEN    // DON'T USE CLOCK WITH UART            (11)
                    |USART_CR2_LBDIE);  // NO LIN BREAK DETECTION INTERRUPT     (6)

    // CONFIGURE USART CR3 REGISTER
    // CLEAR BITS
    USART1->CR3 &= ~(USART_CR3_CTSIE  // NO TRANSMISSION COMPLETE BEFORE GUART TIME INTERRUPT (24)
                    |USART_CR3_DEM      // NO DRIVER ENABLE MODE                                (14)
                    |(0x7F << 3)        // DISABLE VARIOUS IRRELEVANT MODES                     (9-3)
                    |USART_CR3_IREN     // NO IrDA MODE                                         (1)
                    |USART_CR3_EIE);    // INHIBIT ERROR INTERRUPT                              (0)

    // SET BITS
    USART1->CR3 |= (USART_CR3_OVRDIS    // DISABLE OVERRUN FUNCTIONALITY (12)
                   |USART_CR3_ONEBIT);  // USE ONE SAMPLE BIT METHOD     (11)

    // SET BAUD RATE IN BRR REGISTER
    USART1->BRR = 35;                   // VALUE THAT SETS BAUD RATE TO 115,200 AT INPUT FREQUENCY OF 4MHZ

    // ENABLE UART
    USART1->CR1 |= 0b1101;      // ENABLE UART1       (0)

}

void BNO_INITIALIZE() {
	//set clocks
	RCC->AHBENR  |= RCC_AHBENR_GPIOAEN;
	RCC->APB2ENR |= RCC_APB2ENR_USART1EN;

	//Clear pin modes and set to alternate function (A9,A10)
	GPIOA->MODER &= ~((3u << 18) | (3u << 20));
	GPIOA->MODER |= ((2u << 18) | (2u << 20));

	//set alternate function (Table 14 in datasheet)
	GPIOA->AFR[1]  &= ~((15u << 4) | (15u << 8));
	GPIOA->AFR[1]  |=  ((7u << 4) | (7u << 8));
	//pull up/pulldown? speed?

	configUart1();
}

void uart1_send(uint8_t byte) {
    while (!(USART1->ISR & USART_ISR_TXE));
    USART1->TDR = byte;
}

uint8_t uart1_recv(void) {
    while (!(USART1->ISR & USART_ISR_RXNE));
    return USART1->RDR;
}

void read_bno_packet(void) {
    // Read first 4 bytes (SHTP header)
    uint8_t header[4];
    for (int i = 0; i < 4; i++) {
        header[i] = uart1_recv();
    }

    uint16_t packet_len = header[0] | (header[1] << 8);
    //uint8_t channel = header[2];
    //uint8_t seq = header[3];

    packet_len &= 0x7FFF; // Remove MSB

    uint16_t data_len = packet_len - 4;
    uint8_t payload[data_len];

    for (int i = 0; i < data_len; i++) {
        payload[i] = uart1_recv();
    }

    // Now handle the packet
    // For now, just print or inspect the payload
    for(int i = 0; i < data_len; i++) {
    	printf("%u\n", payload[i]);
    }
}

int main(void) {
	printf("Hello");
	BNO_INITIALIZE();
	read_bno_packet();
}
